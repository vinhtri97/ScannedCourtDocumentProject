{"ast":null,"code":"'use strict';\n\nvar nodeUtil = require(\"util\"),\n    _ = require(\"underscore\"),\n    PDFUnit = require('./pdfunit.js');\n\nvar PDFField = function PDFFieldClosure() {\n  'use strict'; // private static\n\n  var _nextId = 1;\n  var _name = 'PDFField';\n  var _tabIndex = 0;\n  var kFBANotOverridable = 0x00000400; // indicates the field is read only by the user\n\n  var kFBARequired = 0x00000010; // indicates the field is required\n\n  var kMinHeight = 20; // constructor\n\n  var cls = function cls(field, viewport, Fields, Boxsets) {\n    // private\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    };\n\n    this.field = field;\n    this.viewport = viewport;\n    this.Fields = Fields;\n    this.Boxsets = Boxsets;\n  }; // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)\n  // For coordinate systems whose origin lies in the bottom-left, this\n  // means normalization to (BL,TR) ordering. For systems with origin in the\n  // top-left, this means (TL,BR) ordering.\n\n\n  var _normalizeRect = function _normalizeRect(rect) {\n    var r = rect.slice(0); // clone rect\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  };\n\n  cls.isWidgetSupported = function (field) {\n    var retVal = false;\n\n    switch (field.fieldType) {\n      case 'Tx':\n        retVal = true;\n        break;\n      //text input\n\n      case 'Btn':\n        if (field.fieldFlags & 32768) {\n          field.fieldType = 'Rd'; //radio button\n        } else if (field.fieldFlags & 65536) {\n          field.fieldType = 'Btn'; //push button\n        } else {\n          field.fieldType = 'Cb'; //checkbox\n        }\n\n        retVal = true;\n        break;\n\n      case 'Ch':\n        retVal = true;\n        break;\n      //drop down\n\n      default:\n        nodeUtil.p2jwarn(\"Unsupported: field.fieldType of \" + field.fieldType);\n        break;\n    }\n\n    return retVal;\n  };\n\n  cls.isFormElement = function (field) {\n    var retVal = false;\n\n    switch (field.subtype) {\n      case 'Widget':\n        retVal = cls.isWidgetSupported(field);\n        break;\n\n      default:\n        nodeUtil.p2jwarn(\"Unsupported: field.type of \" + field.subtype);\n        break;\n    }\n\n    return retVal;\n  };\n\n  var _getFieldPosition = function _getFieldPosition(field) {\n    var viewPort = this.viewport;\n    var fieldRect = viewPort.convertToViewportRectangle(field.rect);\n\n    var rect = _normalizeRect(fieldRect);\n\n    var height = rect[3] - rect[1];\n\n    if (field.fieldType === 'Tx') {\n      if (height > kMinHeight + 2) {\n        rect[1] += 2;\n        height -= 2;\n      }\n    } else if (field.fieldType !== 'Ch') {\n      //checkbox, radio button, and link button\n      rect[1] -= 3;\n    }\n\n    height = height >= kMinHeight ? height : kMinHeight;\n    return {\n      x: PDFUnit.toFormX(rect[0]),\n      y: PDFUnit.toFormY(rect[1]),\n      w: PDFUnit.toFormX(rect[2] - rect[0]),\n      h: PDFUnit.toFormY(height)\n    };\n  };\n\n  var _getFieldBaseData = function _getFieldBaseData(field) {\n    var attributeMask = 0; //PDF Spec p.676 TABLE 8.70 Field flags common to all field types\n\n    if (field.fieldFlags & 0x00000001) {\n      attributeMask |= kFBANotOverridable;\n    }\n\n    if (field.fieldFlags & 0x00000002) {\n      attributeMask |= kFBARequired;\n    }\n\n    var anData = {\n      id: {\n        Id: field.fullName,\n        EN: 0\n      },\n      TI: field.TI,\n      AM: attributeMask\n    }; //PDF Spec p.675: add TU (AlternativeText) fields to provide accessibility info\n\n    if (field.alternativeText && field.alternativeText.length > 1) {\n      anData.TU = field.alternativeText;\n    }\n\n    if (field.alternativeID && field.alternativeID.length > 1) {\n      anData.TM = field.alternativeID;\n    }\n\n    return _.extend(anData, _getFieldPosition.call(this, field));\n  };\n\n  var _addAlpha = function _addAlpha(field) {\n    var anData = _.extend({\n      style: 48,\n      T: {\n        Name: field.TName || \"alpha\",\n        TypeInfo: {}\n      }\n    }, _getFieldBaseData.call(this, field));\n\n    if (field.MV) {\n      //field attributes: arbitrary mask value\n      anData.MV = field.MV;\n    }\n\n    if (field.fieldValue) {\n      anData.V = field.fieldValue; //read-only field value, like \"self-prepared\"\n    }\n\n    this.Fields.push(anData);\n  };\n\n  var _addCheckBox = function _addCheckBox(box) {\n    var anData = _.extend({\n      style: 48,\n      T: {\n        Name: \"box\",\n        TypeInfo: {}\n      }\n    }, _getFieldBaseData.call(this, box));\n\n    this.Boxsets.push({\n      boxes: [anData]\n    });\n  };\n\n  var _addRadioButton = function _addRadioButton(box) {\n    var anData = _.extend({\n      style: 48,\n      T: {\n        Name: \"box\",\n        TypeInfo: {}\n      }\n    }, _getFieldBaseData.call(this, box));\n\n    anData.id.Id = box.value;\n\n    if (_.has(box, 'checked')) {\n      anData.checked = box.checked;\n    }\n\n    var rdGroup = _.find(this.Boxsets, function (boxset) {\n      return _.has(boxset, 'id') && _.has(boxset.id, 'Id') && boxset.id.Id === box.fullName;\n    });\n\n    if (!!rdGroup && _.has(rdGroup, 'boxes')) {\n      rdGroup.boxes.push(anData);\n    } else {\n      this.Boxsets.push({\n        boxes: [anData],\n        id: {\n          Id: box.fullName,\n          EN: 0\n        }\n      });\n    }\n  };\n\n  var _addLinkButton = function _addLinkButton(field) {\n    var anData = _.extend({\n      style: 48,\n      T: {\n        Name: \"link\"\n      },\n      FL: {\n        form: {\n          Id: field.FL\n        }\n      }\n    }, _getFieldBaseData.call(this, field));\n\n    this.Fields.push(anData);\n  };\n\n  var _addSelect = function _addSelect(field) {\n    var anData = _.extend({\n      style: 48,\n      T: {\n        Name: \"alpha\",\n        TypeInfo: {}\n      }\n    }, _getFieldBaseData.call(this, field));\n\n    anData.w -= 0.5; //adjust combobox width\n\n    anData.PL = {\n      V: [],\n      D: []\n    };\n\n    _.each(field.value, function (ele, idx) {\n      anData.PL.D.push(ele[0]);\n      anData.PL.V.push(ele[1]);\n    });\n\n    this.Fields.push(anData);\n  }; // public (every instance will share the same method, but has no access to private fields defined in constructor)\n\n\n  cls.prototype.processField = function () {\n    this.field.TI = _tabIndex++;\n\n    switch (this.field.fieldType) {\n      case 'Tx':\n        _addAlpha.call(this, this.field);\n\n        break;\n\n      case 'Cb':\n        _addCheckBox.call(this, this.field);\n\n        break;\n\n      case 'Rd':\n        _addRadioButton.call(this, this.field);\n\n        break;\n\n      case 'Btn':\n        _addLinkButton.call(this, this.field);\n\n        break;\n\n      case 'Ch':\n        _addSelect.call(this, this.field);\n\n        break;\n    }\n\n    this.clean();\n  };\n\n  cls.prototype.clean = function () {\n    delete this.get_id;\n    delete this.get_name;\n    delete this.field;\n    delete this.viewport;\n    delete this.Fields;\n    delete this.Boxsets;\n  }; //static public method to generate fieldsType object based on parser result\n\n\n  cls.getAllFieldsTypes = function (data) {\n    function isFieldReadOnly(field) {\n      return field.AM & kFBANotOverridable ? true : false;\n    }\n\n    function getFieldBase(field) {\n      return {\n        id: field.id.Id,\n        type: field.T.Name,\n        calc: isFieldReadOnly(field),\n        value: field.V || \"\"\n      };\n    }\n\n    var retVal = [];\n\n    _.each(data.Pages, function (page) {\n      _.each(page.Boxsets, function (boxsets) {\n        if (boxsets.boxes.length > 1) {\n          //radio button\n          _.each(boxsets.boxes, function (box) {\n            retVal.push({\n              id: boxsets.id.Id,\n              type: \"radio\",\n              calc: isFieldReadOnly(box),\n              value: box.id.Id\n            });\n          });\n        } else {\n          //checkbox\n          retVal.push(getFieldBase(boxsets.boxes[0]));\n        }\n      });\n\n      _.each(page.Fields, function (field) {\n        retVal.push(getFieldBase(field));\n      });\n    });\n\n    return retVal;\n  };\n\n  return cls;\n}();\n\nmodule.exports = PDFField;","map":null,"metadata":{},"sourceType":"script"}