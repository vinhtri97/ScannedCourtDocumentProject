{"ast":null,"code":"'use strict';\n\nvar nodeUtil = require(\"util\"),\n    nodeEvents = require(\"events\"),\n    _ = require(\"underscore\"),\n    fs = require('fs'),\n    async = require(\"async\"),\n    PDFJS = require(\"./lib/pdf.js\");\n\nvar PDFParser = function () {\n  // private static\n  var _nextId = 1;\n  var _name = 'PDFParser';\n  var _binBuffer = {};\n  var _maxBinBufferCount = 10; //private methods, needs to invoked by [funcName].call(this, ...)\n\n  var _onPDFJSParseDataReady = function _onPDFJSParseDataReady(data) {\n    if (!data) {\n      //v1.1.2: data===null means end of parsed data\n      this.emit(\"pdfParser_dataReady\", this);\n      nodeUtil.p2jinfo(\"PDF parsing completed.\");\n    } else {\n      Object.assign(this.data, data);\n    }\n  };\n\n  var _onPDFJSParserDataError = function _onPDFJSParserDataError(data) {\n    this.data = data;\n    this.emit(\"pdfParser_dataError\", this);\n  };\n\n  var _startParsingPDF = function _startParsingPDF(buffer) {\n    this.data = {};\n    this.PDFJS.on(\"pdfjs_parseDataReady\", _onPDFJSParseDataReady.bind(this));\n    this.PDFJS.on(\"pdfjs_parseDataError\", _onPDFJSParserDataError.bind(this));\n    this.PDFJS.parsePDFData(buffer || _binBuffer[this.pdfFilePath]);\n  };\n\n  var _processBinaryCache = function _processBinaryCache() {\n    if (_.has(_binBuffer, this.pdfFilePath)) {\n      _startParsingPDF.call(this);\n\n      return true;\n    }\n\n    var allKeys = _.keys(_binBuffer);\n\n    if (allKeys.length > _maxBinBufferCount) {\n      var idx = this.get_id() % _maxBinBufferCount;\n\n      var key = allKeys[idx];\n      _binBuffer[key] = null;\n      delete _binBuffer[key];\n      nodeUtil.p2jinfo(\"re-cycled cache for \" + key);\n    }\n\n    return false;\n  };\n\n  var _processPDFContent = function _processPDFContent(err, data) {\n    nodeUtil.p2jinfo(\"Load PDF file status:\" + (!!err ? \"Error!\" : \"Success!\"));\n\n    if (err) {\n      this.data = err;\n      this.emit(\"pdfParser_dataError\", this);\n    } else {\n      _binBuffer[this.pdfFilePath] = data;\n\n      _startParsingPDF.call(this);\n    }\n  }; // constructor\n\n\n  function PdfParser(context, needRawText) {\n    var _this = this;\n\n    //call constructor for super class\n    nodeEvents.EventEmitter.call(this); // private\n\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    }; // service context object, only used in Web Service project; null in command line\n\n\n    this.context = context;\n    this.pdfFilePath = null; //current PDF file to load and parse, null means loading/parsing not started\n\n    this.data = null; //if file read success, data is PDF content; if failed, data is \"err\" object\n\n    this.PDFJS = new PDFJS(needRawText);\n    this.processFieldInfoXML = false; //disable additional _fieldInfo.xml parsing and merging\n\n    this.fq = async.queue(function (task, callback) {\n      fs.readFile(task.path, callback);\n    }, 100); //public APIs\n\n    this.loadPDF = function (pdfFilePath, verbosity) {\n      nodeUtil.verbosity(verbosity);\n      nodeUtil.p2jinfo(\"about to load PDF file \" + pdfFilePath);\n      _this.pdfFilePath = pdfFilePath;\n\n      if (_this.processFieldInfoXML) {\n        _this.PDFJS.tryLoadFieldInfoXML(pdfFilePath);\n      }\n\n      if (_processBinaryCache.call(_this)) return;\n\n      _this.fq.push({\n        path: pdfFilePath\n      }, _processPDFContent.bind(_this));\n    }; // Introduce a way to directly process buffers without the need to write it to a temporary file\n\n\n    this.parseBuffer = function (pdfBuffer) {\n      _startParsingPDF.call(_this, pdfBuffer);\n    };\n\n    this.getRawTextContent = function () {\n      return _this.PDFJS.getRawTextContent();\n    };\n\n    this.getAllFieldsTypes = function () {\n      return _this.PDFJS.getAllFieldsTypes(_this.data);\n    };\n\n    this.getMergedTextBlocksIfNeeded = function () {\n      return _this.PDFJS.getMergedTextBlocksIfNeeded();\n    };\n\n    this.destroy = function () {\n      _this.removeAllListeners(); //context object will be set in Web Service project, but not in command line utility\n\n\n      if (_this.context) {\n        _this.context.destroy();\n\n        _this.context = null;\n      }\n\n      _this.pdfFilePath = null;\n      _this.data = null;\n\n      _this.PDFJS.destroy();\n\n      _this.PDFJS = null;\n    };\n  } // inherit from event emitter\n\n\n  nodeUtil.inherits(PdfParser, nodeEvents.EventEmitter);\n  return PdfParser;\n}();\n\nmodule.exports = PDFParser;","map":null,"metadata":{},"sourceType":"script"}