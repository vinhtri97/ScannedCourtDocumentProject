{"ast":null,"code":"'use strict';\n\nvar nodeUtil = require(\"util\"),\n    _ = require(\"underscore\"),\n    PDFUnit = require('./pdfunit.js');\n\nvar PDFFont = function PFPFontClosure() {\n  // private static\n  var _nextId = 1;\n  var _name = 'PDFFont';\n  var _boldSubNames = [\"bd\", \"bold\", \"demi\", \"black\"];\n  var _stdFonts = [\"arial\", \"helvetica\", \"sans-serif \", \"courier \", \"monospace \", \"ocr \"];\n  var _kFontFaces = [\"quicktype,arial,helvetica,sans-serif\", // 00 - QuickType - sans-serif variable font\n  \"quicktype condensed,arial narrow,arial,helvetica,sans-serif\", // 01 - QuickType Condensed - thin sans-serif variable font\n  \"quicktypepi,quicktypeiipi\", // 02 - QuickType Pi\n  \"quicktype mono,courier new,courier,monospace\", // 03 - QuickType Mono - san-serif fixed font\n  \"ocr-a,courier new,courier,monospace\", // 04 - OCR-A - OCR readable san-serif fixed font\n  \"ocr b mt,courier new,courier,monospace\" // 05 - OCR-B MT - OCR readable san-serif fixed font\n  ];\n  var _kFontStyles = [// Face\t\tSize\tBold\tItalic\t\tStyleID(Comment)\n  // -----\t----\t----\t-----\t\t-----------------\n  [0, 6, 0, 0], //00\n  [0, 8, 0, 0], //01\n  [0, 10, 0, 0], //02\n  [0, 12, 0, 0], //03\n  [0, 14, 0, 0], //04\n  [0, 18, 0, 0], //05\n  [0, 6, 1, 0], //06\n  [0, 8, 1, 0], //07\n  [0, 10, 1, 0], //08\n  [0, 12, 1, 0], //09\n  [0, 14, 1, 0], //10\n  [0, 18, 1, 0], //11\n  [0, 6, 0, 1], //12\n  [0, 8, 0, 1], //13\n  [0, 10, 0, 1], //14\n  [0, 12, 0, 1], //15\n  [0, 14, 0, 1], //16\n  [0, 18, 0, 1], //17\n  [0, 6, 1, 1], //18\n  [0, 8, 1, 1], //19\n  [0, 10, 1, 1], //20\n  [0, 12, 1, 1], //21\n  [0, 14, 1, 1], //22\n  [0, 18, 1, 1], //23\n  [1, 6, 0, 0], //24\n  [1, 8, 0, 0], //25\n  [1, 10, 0, 0], //26\n  [1, 12, 0, 0], //27\n  [1, 14, 0, 0], //28\n  [1, 18, 0, 0], //29\n  [1, 6, 1, 0], //30\n  [1, 8, 1, 0], //31\n  [1, 10, 1, 0], //32\n  [1, 12, 1, 0], //33\n  [1, 14, 1, 0], //34\n  [1, 18, 1, 0], //35\n  [1, 6, 0, 1], //36\n  [1, 8, 0, 1], //37\n  [1, 10, 0, 1], //38\n  [1, 12, 0, 1], //39\n  [1, 14, 0, 1], //40\n  [1, 18, 0, 1], //41\n  [2, 8, 0, 0], //42\n  [2, 10, 0, 0], //43\n  [2, 12, 0, 0], //44\n  [2, 14, 0, 0], //45\n  [2, 18, 0, 0], //46\n  [3, 8, 0, 0], //47\n  [3, 10, 0, 0], //48\n  [3, 12, 0, 0], //49\n  [4, 12, 0, 0], //50\n  [0, 9, 0, 0], //51\n  [0, 9, 1, 0], //52\n  [0, 9, 0, 1], //53\n  [0, 9, 1, 1], //54\n  [1, 9, 0, 0], //55\n  [1, 9, 1, 0], //56\n  [1, 9, 1, 1], //57\n  [4, 10, 0, 0], //58\n  [5, 10, 0, 0], //59\n  [5, 12, 0, 0] //60\n  ]; // constructor\n\n  var cls = function cls(fontObj) {\n    // private\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    };\n\n    this.fontObj = fontObj;\n    var typeName = fontObj.name || fontObj.fallbackName;\n\n    if (!typeName) {\n      typeName = _kFontFaces[0]; //default font family name\n    }\n\n    typeName = typeName.toLowerCase();\n    this.typeName = typeName;\n    var subType = typeName;\n    var nameArray = typeName.split('+');\n\n    if (_.isArray(nameArray) && nameArray.length > 1) {\n      subType = nameArray[1].split(\"-\");\n\n      if (_.isArray(subType) && subType.length > 1) {\n        if (!this.bold) {\n          var subName = subType[1].toLowerCase();\n          this.bold = _boldSubNames.indexOf(subName) >= 0;\n        }\n\n        subType = subType[0];\n      }\n    }\n\n    this.subType = subType;\n    this.isSymbol = typeName.indexOf(\"symbol\") > 0 || _kFontFaces[2].indexOf(this.subType) >= 0;\n\n    if (this.fontObj.isSymbolicFont) {\n      var mFonts = _.filter(_stdFonts, function (oneName) {\n        return typeName.indexOf(oneName) >= 0;\n      }, this);\n\n      if (mFonts.length > 0) {\n        this.fontObj.isSymbolicFont = false; //lots of Arial-based font is detected as symbol in VA forms (301, 76-c, etc.) reset the flag for now\n\n        nodeUtil.p2jinfo(\"Reset: isSymbolicFont (false) for \" + this.fontObj.name);\n      }\n    } else {\n      if (this.isSymbol) {\n        this.fontObj.isSymbolicFont = true; //text pdf: va_ind_760c\n\n        nodeUtil.p2jinfo(\"Reset: isSymbolicFont (true) for \" + this.fontObj.name);\n      }\n    }\n\n    this.fontSize = 1;\n    this.faceIdx = 0;\n    this.bold = false;\n    this.italic = false;\n    this.fontStyleId = -1;\n    this.spaceWidth = fontObj.spaceWidth;\n\n    if (!this.spaceWidth) {\n      var spaceId = Array.isArray(fontObj.toFontChar) ? fontObj.toFontChar.indexOf(32) : -1;\n      this.spaceWidth = spaceId >= 0 && Array.isArray(fontObj.widths) ? fontObj.widths[spaceId] : 250;\n    }\n\n    this.spaceWidth = PDFUnit.toFormX(this.spaceWidth) / 32;\n  }; // public static\n\n  /** sort text blocks by y then x */\n\n\n  var DISTANCE_DELTA = 0.1;\n\n  cls.compareBlockPos = function (t1, t2) {\n    if (t1.y < t2.y - DISTANCE_DELTA) {\n      return -1;\n    }\n\n    if (Math.abs(t1.y - t2.y) <= DISTANCE_DELTA) {\n      if (t1.x < t2.x - DISTANCE_DELTA) {\n        return -1;\n      }\n\n      if (Math.abs(t1.x - t2.x) <= DISTANCE_DELTA) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n\n  cls.haveSameStyle = function (t1, t2) {\n    var retVal = t1.R[0].S === t2.R[0].S;\n\n    if (retVal && t1.R[0].S < 0) {\n      for (var i = 0; i < t1.R[0].TS.length; i++) {\n        if (t1.R[0].TS[i] !== t2.R[0].TS[i]) {\n          retVal = false;\n          break;\n        }\n      }\n    }\n\n    if (retVal) {\n      // make sure both block are not rotated\n      retVal = typeof t1.R[0].RA === 'undefined' && typeof t2.R[0].RA === 'undefined';\n    }\n\n    return retVal;\n  };\n\n  cls.getSpaceThreshHold = function (t1) {\n    return PDFFont.getFontSize(t1) / 12 * t1.sw;\n  };\n\n  cls.areAdjacentBlocks = function (t1, t2) {\n    var isInSameLine = Math.abs(t1.y - t2.y) <= DISTANCE_DELTA;\n    var isDistanceSmallerThanASpace = Math.abs(t2.x - t1.x - t1.w) < cls.getSpaceThreshHold(t1);\n    return isInSameLine && isDistanceSmallerThanASpace;\n  };\n\n  cls.getFontSize = function (textBlock) {\n    var sId = textBlock.R[0].S;\n    return sId < 0 ? textBlock.R[0].TS[1] : _kFontStyles[sId][1];\n  };\n\n  cls.areDuplicateBlocks = function (t1, t2) {\n    return t1.x == t2.x && t1.y == t2.y && t1.R[0].T == t2.R[0].T && cls.haveSameStyle(t1, t2);\n  }; // private\n\n\n  var _setFaceIndex = function _setFaceIndex() {\n    var fontObj = this.fontObj;\n    this.bold = fontObj.bold;\n\n    if (!this.bold) {\n      this.bold = this.typeName.indexOf(\"bold\") >= 0 || this.typeName.indexOf(\"black\") >= 0;\n    }\n\n    this.italic = fontObj.italic; // fix https://github.com/modesty/pdf2json/issues/42\n\n    var typeName = this.subType;\n\n    if (fontObj.isSerifFont) {\n      if (_kFontFaces[1].indexOf(typeName) >= 0) this.faceIdx = 1;\n    } else if (_kFontFaces[2].indexOf(this.subType) >= 0) {\n      this.faceIdx = 2;\n    } else if (fontObj.isMonospace) {\n      this.faceIdx = 3;\n      if (_kFontFaces[4].indexOf(typeName) >= 0) this.faceIdx = 4;else if (_kFontFaces[5].indexOf(typeName) >= 0) this.faceIdx = 5;\n    } else if (fontObj.isSymbolicFont) {\n      this.faceIdx = 2;\n    }\n\n    if (this.faceIdx == 0) {\n      if (this.typeName.indexOf(\"narrow\") > 0) this.faceIdx = 1;\n    } //        nodeUtil.p2jinfo\"typeName = \" + typeName + \" => faceIdx = \" + this.faceIdx);\n\n  };\n\n  var _getFontStyleIndex = function _getFontStyleIndex(fontSize) {\n    _setFaceIndex.call(this); //MQZ Feb.28.2013. Adjust bold text fontsize to work around word spacing issue\n\n\n    this.fontSize = this.bold && fontSize > 12 ? fontSize + 1 : fontSize;\n    var fsa = [this.faceIdx, this.fontSize, this.bold ? 1 : 0, this.italic ? 1 : 0];\n    var retVal = -1;\n\n    _.each(_kFontStyles, function (element, index, list) {\n      if (retVal === -1) {\n        if (element[0] === fsa[0] && element[1] === fsa[1] && element[2] === fsa[2] && element[3] === fsa[3]) {\n          retVal = index;\n        }\n      }\n    });\n\n    return retVal;\n  };\n\n  var _processSymbolicFont = function _processSymbolicFont(str) {\n    var retVal = str;\n    if (!str || str.length !== 1) return retVal;\n\n    if (!this.fontObj.isSymbolicFont || !this.isSymbol) {\n      if (retVal == \"C\" || retVal == \"G\") {\n        //prevent symbolic encoding from the client\n        retVal = \" \" + retVal + \" \"; //sample: va_ind_760c\n      }\n\n      return retVal;\n    }\n\n    switch (str.charCodeAt(0)) {\n      case 20:\n        retVal = \"\\u2713\";\n        break;\n      //check mark\n\n      case 70:\n        retVal = this.fontObj.type === \"CIDFontType0\" ? \"\\u26A0\" : \"}\";\n        break;\n      //exclaimation in triangle OR right curly bracket\n\n      case 71:\n        retVal = \"\\u25B6\";\n        break;\n      //right triangle\n\n      case 97:\n        retVal = \"\\u25B6\";\n        break;\n      //right triangle\n\n      case 99:\n        retVal = this.isSymbol ? \"\\u2022\" : \"\\u25B2\";\n        break;\n      //up triangle. set to Bullet Dot for VA SchSCR\n\n      case 100:\n        retVal = \"\\u25BC\";\n        break;\n      //down triangle\n\n      case 103:\n        retVal = \"\\u27A8\";\n        break;\n      //right arrow. sample: va_ind_760pff and pmt\n\n      case 106:\n        retVal = '';\n        break;\n      //VA 301: string j character by the checkbox, hide it for now\n\n      case 114:\n        retVal = \"\\u2022\";\n        break;\n      //Bullet dot\n\n      case 115:\n        retVal = \"\\u25B2\";\n        break;\n      //up triangle\n\n      case 116:\n        retVal = \"\\u2022\";\n        break;\n      //Bullet dot\n\n      case 118:\n        retVal = \"\\u2022\";\n        break;\n      //Bullet dot\n\n      default:\n        nodeUtil.p2jinfo(this.fontObj.type + \" - SymbolicFont - (\" + this.fontObj.name + \") : \" + str.charCodeAt(0) + \"::\" + str.charCodeAt(1) + \" => \" + retVal);\n    }\n\n    return retVal;\n  };\n\n  var _textRotationAngle = function _textRotationAngle(matrix2D) {\n    var retVal = 0;\n\n    if (matrix2D[0][0] === 0 && matrix2D[1][1] === 0) {\n      if (matrix2D[0][1] != 0 && matrix2D[1][0] != 0) {\n        if (matrix2D[0][1] / matrix2D[1][0] + 1 < 0.0001) retVal = 90;\n      }\n    } else if (matrix2D[0][0] !== 0 && matrix2D[1][1] !== 0) {\n      var r1 = Math.atan(-matrix2D[0][1] / matrix2D[0][0]);\n      var r2 = Math.atan(matrix2D[1][0] / matrix2D[1][1]);\n\n      if (Math.abs(r1) > 0.0001 && r1 - r2 < 0.0001) {\n        retVal = r1 * 180 / Math.PI;\n      }\n    }\n\n    return retVal;\n  }; // public (every instance will share the same method, but has no access to private fields defined in constructor)\n\n\n  cls.prototype.processText = function (p, str, maxWidth, color, fontSize, targetData, matrix2D) {\n    var text = _processSymbolicFont.call(this, str);\n\n    if (!text) {\n      return;\n    }\n\n    this.fontStyleId = _getFontStyleIndex.call(this, fontSize); // when this.fontStyleId === -1, it means the text style doesn't match any entry in the dictionary\n    // adding TS to better describe text style [fontFaceId, fontSize, 1/0 for bold, 1/0 for italic];\n\n    var TS = [this.faceIdx, this.fontSize, this.bold ? 1 : 0, this.italic ? 1 : 0];\n    var clrId = PDFUnit.findColorIndex(color);\n    var oneText = {\n      x: PDFUnit.toFormX(p.x) - 0.25,\n      y: PDFUnit.toFormY(p.y) - 0.75,\n      w: PDFUnit.toFixedFloat(maxWidth),\n      sw: this.spaceWidth,\n      //font space width, use to merge adjacent text blocks\n      clr: clrId,\n      A: \"left\",\n      R: [{\n        T: this.flash_encode(text),\n        S: this.fontStyleId,\n        TS: TS\n      }]\n    }; //MQZ.07/29/2013: when color is not in color dictionary, set the original color (oc)\n\n    if (clrId < 0) {\n      oneText = _.extend({\n        oc: color\n      }, oneText);\n    }\n\n    var rAngle = _textRotationAngle.call(this, matrix2D);\n\n    if (rAngle != 0) {\n      nodeUtil.p2jinfo(str + \": rotated \" + rAngle + \" degree.\");\n\n      _.extend(oneText.R[0], {\n        RA: rAngle\n      });\n    }\n\n    targetData.Texts.push(oneText);\n  };\n\n  cls.prototype.flash_encode = function (str) {\n    var retVal = encodeURIComponent(str);\n    retVal = retVal.replace(\"%C2%96\", \"-\");\n    retVal = retVal.replace(\"%C2%91\", \"%27\");\n    retVal = retVal.replace(\"%C2%92\", \"%27\");\n    retVal = retVal.replace(\"%C2%82\", \"%27\");\n    retVal = retVal.replace(\"%C2%93\", \"%22\");\n    retVal = retVal.replace(\"%C2%94\", \"%22\");\n    retVal = retVal.replace(\"%C2%84\", \"%22\");\n    retVal = retVal.replace(\"%C2%8B\", \"%C2%AB\");\n    retVal = retVal.replace(\"%C2%9B\", \"%C2%BB\");\n    return retVal;\n  };\n\n  cls.prototype.clean = function () {\n    this.fontObj = null;\n    delete this.fontObj;\n  };\n\n  return cls;\n}();\n\nmodule.exports = PDFFont;","map":null,"metadata":{},"sourceType":"script"}