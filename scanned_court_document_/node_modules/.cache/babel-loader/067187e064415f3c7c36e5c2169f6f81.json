{"ast":null,"code":"'use strict';\n\nvar nodeUtil = require(\"util\"),\n    nodeEvents = require(\"events\"),\n    fs = require('fs'),\n    _ = require('underscore'),\n    DOMParser = require('xmldom').DOMParser,\n    PDFCanvas = require('./pdfcanvas.js'),\n    PDFUnit = require('./pdfunit.js'),\n    PDFField = require('./pdffield.js'),\n    PDFAnno = require('./pdfanno.js'),\n    Image = require('./pdfimage.js'),\n    pkInfo = require('../package.json'),\n    PDFFont = require('./pdffont');\n\nvar _pdfjsFiles = ['shared/util.js', 'shared/colorspace.js', 'shared/pattern.js', 'shared/function.js', 'shared/annotation.js', 'core/core.js', 'core/obj.js', 'core/charsets.js', 'core/crypto.js', 'core/evaluator.js', 'core/fonts.js', 'core/font_renderer.js', 'core/glyphlist.js', 'core/image.js', 'core/metrics.js', 'core/parser.js', 'core/stream.js', 'core/worker.js', 'core/jpx.js', 'core/jbig2.js', 'core/bidi.js', 'core/jpg.js', 'core/chunked_stream.js', 'core/pdf_manager.js', 'core/cmap.js', 'core/cidmaps.js', 'display/canvas.js', 'display/font_loader.js', 'display/metadata.js', 'display/api.js'];\n\nvar _PARSER_SIG = \"\".concat(pkInfo.name, \"@\").concat(pkInfo.version, \" [\").concat(pkInfo.homepage, \"]\"); //////replacing HTML5 canvas with PDFCanvas (in-memory canvas)\n\n\nfunction createScratchCanvas(width, height) {\n  return new PDFCanvas({}, width, height);\n}\n\nvar PDFJS = {};\nvar globalScope = {\n  console: console\n};\n\nvar _basePath = __dirname + \"/../base/\";\n\nvar _fileContent = '';\n\n_pdfjsFiles.forEach(function (fieldName, idx, arr) {\n  return _fileContent += fs.readFileSync(_basePath + fieldName, 'utf8');\n});\n\neval(_fileContent); ////////////////////////////////start of helper classes\n\nvar PDFPageParser = function () {\n  // private static\n  var _nextId = 1;\n  var _name = 'PDFPageParser';\n  var RenderingStates = {\n    INITIAL: 0,\n    RUNNING: 1,\n    PAUSED: 2,\n    FINISHED: 3\n  };\n\n  var _addField = function _addField(field) {\n    if (!PDFField.isFormElement(field)) return;\n    var oneField = new PDFField(field, this.viewport, this.Fields, this.Boxsets);\n    oneField.processField();\n  }; // constructor\n\n\n  var cls = function cls(pdfPage, id, scale, ptiParser) {\n    nodeEvents.EventEmitter.call(this); // private\n\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    }; // public, this instance copies\n\n\n    this.id = id;\n    this.pdfPage = pdfPage;\n    this.ptiParser = ptiParser;\n    this.scale = scale || 1.0; //leave out the 2nd parameter in order to use page's default rotation (for both portrait and landscape form)\n\n    this.viewport = this.pdfPage.getViewport(this.scale);\n    this.renderingState = RenderingStates.INITIAL; //form elements other than radio buttons and check boxes\n\n    this.Fields = []; //form elements: radio buttons and check boxes\n\n    this.Boxsets = []; //public properties\n\n    Object.defineProperty(this, 'width', {\n      get: function get() {\n        return PDFUnit.toFormX(this.viewport.width);\n      },\n      enumerable: true\n    });\n    Object.defineProperty(this, 'height', {\n      get: function get() {\n        return PDFUnit.toFormY(this.viewport.height);\n      },\n      enumerable: true\n    });\n  }; // inherit from event emitter\n\n\n  nodeUtil.inherits(cls, nodeEvents.EventEmitter);\n\n  cls.prototype.destroy = function () {\n    this.pdfPage.destroy();\n    this.pdfPage = null;\n    this.ptiParser = null;\n    this.Fields = null;\n    this.Boxsets = null;\n  };\n\n  cls.prototype.getPagePoint = function (x, y) {\n    return this.viewport.convertToPdfPoint(x, y);\n  };\n\n  cls.prototype.parsePage = function (callback, errorCallBack) {\n    var _this = this;\n\n    if (this.renderingState !== RenderingStates.INITIAL) error('Must be in new state before drawing');\n    this.renderingState = RenderingStates.RUNNING;\n    var canvas = createScratchCanvas(1, 1);\n    var ctx = canvas.getContext('2d');\n\n    function pageViewDrawCallback(error) {\n      this.renderingState = RenderingStates.FINISHED;\n\n      if (error) {\n        var errMsg = 'An error occurred while rendering the page ' + (this.id + 1) + ':\\n' + error.message + ':\\n' + error.stack;\n        errorCallBack(errMsg);\n      } else {\n        if (this.ptiParser) {\n          var extraFields = this.ptiParser.getFields(parseInt(this.id) + 1);\n\n          _.each(extraFields, _addField, this);\n        }\n\n        _.extend(this, ctx.canvas);\n\n        this.stats = this.pdfPage.stats;\n        nodeUtil.p2jinfo('page ' + (this.id + 1) + ' is rendered successfully.');\n        callback();\n      }\n    }\n\n    var renderContext = {\n      canvasContext: ctx,\n      viewport: this.viewport\n    };\n    this.pdfPage.render(renderContext).then(function (data) {\n      _this.pdfPage.getAnnotations().then(function (fields) {\n        _.each(fields, _addField, _this);\n\n        pageViewDrawCallback.call(_this, null);\n      }, function (err) {\n        return console.error(\"pdfPage.getAnnotations error:\" + err);\n      });\n    }, function (err) {\n      return pageViewDrawCallback.call(_this, err);\n    });\n  };\n\n  return cls;\n}(); ////////////////////////////////Start of Node.js Module\n\n\nvar PDFJSClass = function () {\n  // private static\n  var _nextId = 1;\n  var _name = 'PDFJSClass';\n  var _sufInfo = \"_fieldInfo.xml\";\n\n  var _getMetaDataString = function _getMetaDataString(metadata, key) {\n    var retVal = \"unknown\";\n\n    if (metadata && metadata.has(key)) {\n      retVal = encodeURIComponent(metadata.get(key));\n    }\n\n    return retVal;\n  };\n\n  var _getMetaDataInt = function _getMetaDataInt(metadata, key) {\n    var retVal = _getMetaDataString(metadata, key);\n\n    retVal = parseInt(retVal);\n    if (retVal == null || isNaN(retVal)) retVal = -1;\n    return retVal;\n  }; // constructor\n\n\n  var cls = function cls(needRawText) {\n    nodeEvents.EventEmitter.call(this); // private\n\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    }; // public, this instance copies\n\n\n    this.pdfDocument = null;\n    this.pages = [];\n    this.pageWidth = 0;\n    this.rawTextContents = [];\n    this.needRawText = needRawText;\n  }; // inherit from event emitter\n\n\n  nodeUtil.inherits(cls, nodeEvents.EventEmitter);\n\n  cls.prototype.raiseErrorEvent = function (errMsg) {\n    var _this2 = this;\n\n    console.error(errMsg);\n    process.nextTick(function () {\n      return _this2.emit(\"pdfjs_parseDataError\", errMsg);\n    });\n    return errMsg;\n  };\n\n  cls.prototype.raiseReadyEvent = function (data) {\n    var _this3 = this;\n\n    process.nextTick(function () {\n      return _this3.emit(\"pdfjs_parseDataReady\", data);\n    });\n    return data;\n  };\n\n  cls.prototype.parsePDFData = function (arrayBuffer) {\n    var _this4 = this;\n\n    this.pdfDocument = null;\n    var parameters = {\n      password: '',\n      data: arrayBuffer\n    };\n    PDFJS.getDocument(parameters).then(function (pdfDocument) {\n      return _this4.load(pdfDocument, 1);\n    }, function (error) {\n      return _this4.raiseErrorEvent(\"An error occurred while parsing the PDF: \" + error);\n    });\n  };\n\n  cls.prototype.tryLoadFieldInfoXML = function (pdfFilePath) {\n    var _this5 = this;\n\n    var fieldInfoXMLPath = pdfFilePath.replace(\".pdf\", _sufInfo);\n\n    if (fieldInfoXMLPath.indexOf(_sufInfo) < 1 || !fs.existsSync(fieldInfoXMLPath)) {\n      return;\n    }\n\n    nodeUtil.p2jinfo(\"About to load fieldInfo XML : \" + fieldInfoXMLPath);\n\n    var PTIXmlParser = require('./ptixmlinject');\n\n    this.ptiParser = new PTIXmlParser();\n    this.ptiParser.parseXml(fieldInfoXMLPath, function (err) {\n      if (err) {\n        nodeUtil.p2jwarn(\"fieldInfo XML Error: \" + JSON.stringify(err));\n        _this5.ptiParser = null;\n      } else {\n        nodeUtil.p2jinfo(\"fieldInfo XML loaded.\");\n      }\n    });\n  };\n\n  cls.prototype.load = function (pdfDocument, scale) {\n    var _this6 = this;\n\n    this.pdfDocument = pdfDocument;\n    return this.loadMetaData().then(function () {\n      return _this6.loadPages();\n    }, function (error) {\n      return _this6.raiseErrorEvent(\"loadMetaData error: \" + error);\n    });\n  };\n\n  cls.prototype.loadMetaData = function () {\n    var _this7 = this;\n\n    return this.pdfDocument.getMetadata().then(function (data) {\n      _this7.documentInfo = data.info;\n      _this7.metadata = data.metadata;\n\n      _this7.parseMetaData();\n    }, function (error) {\n      return _this7.raiseErrorEvent(\"pdfDocument.getMetadata error: \" + error);\n    });\n  };\n\n  cls.prototype.parseMetaData = function () {\n    var info = this.documentInfo;\n    var metadata = this.metadata;\n    var pdfTile = \"\";\n\n    if (metadata && metadata.has('dc:title')) {\n      pdfTile = metadata.get('dc:title');\n    } else if (info && info['Title']) pdfTile = info['Title'];\n\n    var formAttr = {\n      AgencyId: \"\",\n      Name: \"\",\n      MC: false,\n      Max: 1,\n      Parent: \"\"\n    };\n\n    if (metadata) {\n      formAttr.AgencyId = _getMetaDataString(metadata, 'pdfx:agencyid');\n      if (formAttr.AgencyId != \"unknown\") pdfTile = formAttr.AgencyId;\n      formAttr.Name = _getMetaDataString(metadata, 'pdfx:name');\n      formAttr.MC = _getMetaDataString(metadata, 'pdfx:mc') === 'true';\n      formAttr.Max = _getMetaDataInt(metadata, 'pdfx:max');\n      formAttr.Parent = _getMetaDataInt(metadata, 'pdfx:parent');\n    }\n\n    this.raiseReadyEvent({\n      Transcoder: _PARSER_SIG,\n      Agency: pdfTile,\n      Id: formAttr\n    });\n  };\n\n  cls.prototype.loadPages = function () {\n    var _this8 = this;\n\n    var pagesCount = this.pdfDocument.numPages;\n    var pagePromises = [];\n\n    for (var i = 1; i <= pagesCount; i++) {\n      pagePromises.push(this.pdfDocument.getPage(i));\n    }\n\n    var pagesPromise = PDFJS.Promise.all(pagePromises);\n    nodeUtil.p2jinfo(\"PDF loaded. pagesCount = \" + pagesCount);\n    return pagesPromise.then(function (promisedPages) {\n      return _this8.parsePage(promisedPages, 0, 1.5);\n    }, function (error) {\n      return _this8.raiseErrorEvent(\"pagesPromise error: \" + error);\n    });\n  };\n\n  cls.prototype.parsePage = function (promisedPages, id, scale) {\n    var _this10 = this;\n\n    nodeUtil.p2jinfo(\"start to parse page:\" + (id + 1));\n    var pdfPage = promisedPages[id];\n    var pageParser = new PDFPageParser(pdfPage, id, scale, this.ptiParser);\n\n    function continueOnNextPage() {\n      var _this9 = this;\n\n      nodeUtil.p2jinfo(\"complete parsing page:\" + (id + 1));\n\n      if (id === this.pdfDocument.numPages - 1) {\n        this.raiseReadyEvent({\n          Pages: this.pages,\n          Width: this.pageWidth\n        }); //v1.1.2: signal end of parsed data with null\n\n        process.nextTick(function () {\n          return _this9.raiseReadyEvent(null);\n        });\n      } else {\n        process.nextTick(function () {\n          return _this9.parsePage(promisedPages, ++id, scale);\n        });\n      }\n    }\n\n    pageParser.parsePage(function (data) {\n      if (!_this10.pageWidth) //get PDF width\n        _this10.pageWidth = pageParser.width;\n      var page = {\n        Height: pageParser.height,\n        HLines: pageParser.HLines,\n        VLines: pageParser.VLines,\n        Fills: pageParser.Fills,\n        //needs to keep current default output format, text content will output to a separate file if '-c' command line argument is set\n        //                Content:pdfPage.getTextContent(),\n        Texts: pageParser.Texts,\n        Fields: pageParser.Fields,\n        Boxsets: pageParser.Boxsets\n      };\n\n      _this10.pages.push(page);\n\n      if (_this10.needRawText) {\n        pdfPage.getTextContent().then(function (textContent) {\n          _this10.rawTextContents.push(textContent);\n\n          nodeUtil.p2jinfo(\"complete parsing raw text content:\" + (id + 1));\n          continueOnNextPage.call(_this10);\n        }, function (error) {\n          return _this10.raiseErrorEvent(\"pdfPage.getTextContent error: \" + error);\n        });\n      } else {\n        continueOnNextPage.call(_this10);\n      }\n    }, function (errMsg) {\n      return _this10.raiseErrorEvent(\"parsePage error:\" + errMsg);\n    });\n  };\n\n  cls.prototype.getRawTextContent = function () {\n    var retVal = \"\";\n    if (!this.needRawText) return retVal;\n\n    _.each(this.rawTextContents, function (textContent, index) {\n      var prevText = null;\n\n      _.each(textContent.bidiTexts, function (textObj, idx) {\n        if (prevText) {\n          if (Math.abs(textObj.y - prevText.y) <= 20) {\n            prevText.str += textObj.str;\n          } else {\n            retVal += prevText.str + \"\\r\\n\";\n            prevText = textObj;\n          }\n        } else {\n          prevText = textObj;\n        }\n      });\n\n      if (prevText) {\n        retVal += prevText.str;\n      }\n\n      retVal += \"\\r\\n----------------Page (\" + index + \") Break----------------\\r\\n\";\n    });\n\n    return retVal;\n  };\n\n  cls.prototype.getAllFieldsTypes = function () {\n    return PDFField.getAllFieldsTypes({\n      Pages: this.pages || [],\n      Width: this.pageWidth\n    });\n  };\n\n  cls.prototype.getMergedTextBlocksIfNeeded = function () {\n    var _this11 = this;\n\n    var _loop = function _loop(p) {\n      var prevText = null;\n      var page = _this11.pages[p];\n      page.Texts.sort(PDFFont.compareBlockPos);\n      page.Texts = page.Texts.filter(function (t, j) {\n        var isDup = j > 0 && PDFFont.areDuplicateBlocks(page.Texts[j - 1], t);\n\n        if (isDup) {\n          nodeUtil.p2jinfo(\"skipped: dup text block: \" + decodeURIComponent(t.R[0].T));\n        }\n\n        return !isDup;\n      });\n\n      for (var i = 0; i < page.Texts.length; i++) {\n        var text = page.Texts[i];\n\n        if (prevText) {\n          if (PDFFont.areAdjacentBlocks(prevText, text) && PDFFont.haveSameStyle(prevText, text)) {\n            var preT = decodeURIComponent(prevText.R[0].T);\n            var curT = decodeURIComponent(text.R[0].T); //let distance = Math.abs(text.x - prevText.x - prevText.w);\n            //let textSize = PDFFont.getFontSize(prevText);\n            //let spaceWidth = text.sw;\n            //let threshHold = PDFFont.getSpaceThreshHold(prevText);\n            //console.log(`\\ndistance=${distance}\\tthreshHold=${threshHold}\\ttextSize=${textSize}\\tspaceWidth=${spaceWidth}`);\n\n            prevText.R[0].T += text.R[0].T;\n            prevText.w += text.w;\n            text.merged = true;\n            var mergedText = decodeURIComponent(prevText.R[0].T);\n            nodeUtil.p2jinfo(\"merged text block: \".concat(preT, \" + \").concat(curT, \" => \").concat(mergedText));\n          } else {\n            prevText = null;\n          }\n        } else {\n          prevText = text;\n        }\n      }\n\n      page.Texts = page.Texts.filter(function (t) {\n        return !t.merged;\n      });\n    };\n\n    for (var p = 0; p < this.pages.length; p++) {\n      _loop(p);\n    }\n\n    return this.pages;\n  };\n\n  cls.prototype.destroy = function () {\n    this.removeAllListeners();\n    if (this.pdfDocument) this.pdfDocument.destroy();\n    this.pdfDocument = null;\n    this.pages = null;\n    this.rawTextContents = null;\n  };\n\n  return cls;\n}();\n\nmodule.exports = PDFJSClass;","map":null,"metadata":{},"sourceType":"script"}