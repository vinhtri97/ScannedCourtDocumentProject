{"ast":null,"code":"'use strict';\n\nvar nodeUtil = require(\"util\"),\n    _ = require('underscore'),\n    PDFLine = require('./pdfline'),\n    PDFFill = require('./pdffill'),\n    PDFFont = require('./pdffont');\n\n(function () {\n  // private static\n  var _nextId = 1;\n  var _name = 'PDFCanvas'; // alias some functions to make (compiled) code shorter\n\n  var m = Math;\n  var mr = m.round;\n  var ms = m.sin;\n  var mc = m.cos;\n  var abs = m.abs;\n  var sqrt = m.sqrt; // precompute \"00\" to \"FF\"\n\n  var dec2hex = [];\n\n  for (var i = 0; i < 16; i++) {\n    for (var j = 0; j < 16; j++) {\n      dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);\n    }\n  }\n\n  function createMatrixIdentity() {\n    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n  }\n\n  function matrixMultiply(m1, m2) {\n    var result = createMatrixIdentity();\n\n    for (var x = 0; x < 3; x++) {\n      for (var y = 0; y < 3; y++) {\n        var sum = 0;\n\n        for (var z = 0; z < 3; z++) {\n          sum += m1[x][z] * m2[z][y];\n        }\n\n        result[x][y] = sum;\n      }\n    }\n\n    return result;\n  }\n\n  function copyState(o1, o2) {\n    o2.fillStyle = o1.fillStyle;\n    o2.lineCap = o1.lineCap;\n    o2.lineJoin = o1.lineJoin;\n    o2.lineWidth = o1.lineWidth;\n    o2.miterLimit = o1.miterLimit;\n    o2.shadowBlur = o1.shadowBlur;\n    o2.shadowColor = o1.shadowColor;\n    o2.shadowOffsetX = o1.shadowOffsetX;\n    o2.shadowOffsetY = o1.shadowOffsetY;\n    o2.strokeStyle = o1.strokeStyle;\n    o2.globalAlpha = o1.globalAlpha;\n    o2.arcScaleX_ = o1.arcScaleX_;\n    o2.arcScaleY_ = o1.arcScaleY_;\n    o2.lineScale_ = o1.lineScale_;\n    o2.dashArray = o1.dashArray;\n  }\n\n  function processStyle(styleString) {\n    var str,\n        alpha = 1;\n    styleString = String(styleString);\n\n    if (styleString.substring(0, 3) == 'rgb') {\n      var start = styleString.indexOf('(', 3);\n      var end = styleString.indexOf(')', start + 1);\n      var guts = styleString.substring(start + 1, end).split(',');\n      str = '#';\n\n      for (var _i = 0; _i < 3; _i++) {\n        str += dec2hex[Number(guts[_i])];\n      }\n\n      if (guts.length == 4 && styleString.substr(3, 1) == 'a') {\n        alpha = guts[3];\n      }\n    } else {\n      str = styleString;\n    }\n\n    return {\n      color: str,\n      alpha: alpha\n    };\n  }\n\n  function processLineCap(lineCap) {\n    switch (lineCap) {\n      case 'butt':\n        return 'flat';\n\n      case 'round':\n        return 'round';\n\n      case 'square':\n      default:\n        return 'square';\n    }\n  }\n  /**\n   * This class implements CanvasRenderingContext2D interface as described by\n   * the WHATWG.\n   * @param {HTMLElement} surfaceElement The element that the 2D context should\n   * be associated with\n   */\n\n\n  function CanvasRenderingContext2D_(canvasTarget, scaledWidth, scaledHeight) {\n    // private\n    var _id = _nextId++; // public (every instance will have their own copy of these methods, needs to be lightweight)\n\n\n    this.get_id = function () {\n      return _id;\n    };\n\n    this.get_name = function () {\n      return _name + _id;\n    };\n\n    this.m_ = createMatrixIdentity();\n    this.mStack_ = [];\n    this.aStack_ = [];\n    this.currentPath_ = []; // Canvas context properties\n\n    this.strokeStyle = '#000';\n    this.fillStyle = '#000';\n    this.lineWidth = 1;\n    this.lineJoin = 'miter';\n    this.lineCap = 'butt';\n    this.dashArray = [];\n    this.miterLimit = 1;\n    this.globalAlpha = 1;\n    if (!_.has(canvasTarget, \"HLines\") || !_.isArray(canvasTarget.HLines)) canvasTarget.HLines = [];\n    if (!_.has(canvasTarget, \"VLines\") || !_.isArray(canvasTarget.VLines)) canvasTarget.VLines = [];\n    if (!_.has(canvasTarget, \"Fills\") || !_.isArray(canvasTarget.Fills)) canvasTarget.Fills = [];\n    if (!_.has(canvasTarget, \"Texts\") || !_.isArray(canvasTarget.Texts)) canvasTarget.Texts = [];\n    this.canvas = canvasTarget;\n    this.width = scaledWidth;\n    this.height = scaledHeight;\n    this.arcScaleX_ = 1;\n    this.arcScaleY_ = 1;\n    this.lineScale_ = 1;\n    this.currentFont = null;\n  } //private helper methods\n\n\n  var _drawPDFLine = function _drawPDFLine(p1, p2, lineWidth, color) {\n    var dashedLine = _.isArray(this.dashArray) && this.dashArray.length > 1;\n    var pL = new PDFLine(p1.x, p1.y, p2.x, p2.y, lineWidth, color, dashedLine);\n    pL.processLine(this.canvas);\n  };\n\n  var _drawPDFFill = function _drawPDFFill(cp, min, max, color) {\n    var width = max.x - min.x;\n    var height = max.y - min.y;\n    var pF = new PDFFill(cp.x, cp.y, width, height, color);\n    pF.processFill(this.canvas);\n  };\n\n  var _needRemoveRect = function _needRemoveRect(x, y, w, h) {\n    var retVal = Math.abs(w - Math.abs(h)) < 1 && w < 13;\n\n    if (retVal) {\n      nodeUtil.p2jinfo(\"Skipped: tiny rect: w=\" + w + \", h=\" + h);\n    }\n\n    return retVal;\n  };\n\n  var contextPrototype = CanvasRenderingContext2D_.prototype;\n\n  contextPrototype.getContext = function (ctxType) {\n    return ctxType === \"2d\" ? this : null;\n  };\n\n  contextPrototype.setLineDash = function (lineDash) {\n    this.dashArray = lineDash;\n  };\n\n  contextPrototype.getLineDash = function () {\n    return this.dashArray;\n  };\n\n  contextPrototype.fillText = function (text, x, y, maxWidth, fontSize) {\n    if (!text || text.trim().length < 1) return;\n    var p = this.getCoords_(x, y);\n    var a = processStyle(this.fillStyle || this.strokeStyle);\n    var color = !!a ? a.color : '#000000';\n    this.currentFont.processText(p, text, maxWidth, color, fontSize, this.canvas, this.m_);\n  };\n\n  contextPrototype.strokeText = function (text, x, y, maxWidth) {\n    //MQZ. 10/23/2012, yeah, no hollow text for now\n    this.fillText(text, x, y, maxWidth);\n  };\n\n  contextPrototype.measureText = function (text) {\n    console.warn(\"to be implemented: contextPrototype.measureText - \", text);\n    var chars = text.length || 1;\n    return {\n      width: chars * (this.currentFont.spaceWidth || 5)\n    };\n  };\n\n  contextPrototype.setFont = function (fontObj) {\n    if (!!this.currentFont && _.isFunction(this.currentFont.clean)) {\n      this.currentFont.clean();\n      this.currentFont = null;\n    }\n\n    this.currentFont = new PDFFont(fontObj);\n  };\n\n  contextPrototype.clearRect = function () {};\n\n  contextPrototype.beginPath = function () {\n    // TODO: Branch current matrix so that save/restore has no effect\n    //       as per safari docs.\n    this.currentPath_ = [];\n  };\n\n  contextPrototype.moveTo = function (aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({\n      type: 'moveTo',\n      x: p.x,\n      y: p.y\n    });\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.lineTo = function (aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({\n      type: 'lineTo',\n      x: p.x,\n      y: p.y\n    });\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    var cp1 = this.getCoords_(aCP1x, aCP1y);\n    var cp2 = this.getCoords_(aCP2x, aCP2y);\n    bezierCurveTo(this, cp1, cp2, p);\n  }; // Helper function that takes the already fixed cordinates.\n\n\n  function bezierCurveTo(self, cp1, cp2, p) {\n    self.currentPath_.push({\n      type: 'bezierCurveTo',\n      cp1x: cp1.x,\n      cp1y: cp1.y,\n      cp2x: cp2.x,\n      cp2y: cp2.y,\n      x: p.x,\n      y: p.y\n    });\n    self.currentX_ = p.x;\n    self.currentY_ = p.y;\n  }\n\n  contextPrototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {\n    // the following is lifted almost directly from\n    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes\n    var cp = this.getCoords_(aCPx, aCPy);\n    var p = this.getCoords_(aX, aY);\n    var cp1 = {\n      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),\n      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)\n    };\n    var cp2 = {\n      x: cp1.x + (p.x - this.currentX_) / 3.0,\n      y: cp1.y + (p.y - this.currentY_) / 3.0\n    };\n    bezierCurveTo(this, cp1, cp2, p);\n  };\n\n  contextPrototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    var arcType = aClockwise ? 'at' : 'wa';\n    var xStart = aX + mc(aStartAngle) * aRadius;\n    var yStart = aY + ms(aStartAngle) * aRadius;\n    var xEnd = aX + mc(aEndAngle) * aRadius;\n    var yEnd = aY + ms(aEndAngle) * aRadius; // IE won't render arches drawn counter clockwise if xStart == xEnd.\n\n    if (xStart == xEnd && !aClockwise) {\n      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something\n      // that can be represented in binary\n    }\n\n    var p = this.getCoords_(aX, aY);\n    var pStart = this.getCoords_(xStart, yStart);\n    var pEnd = this.getCoords_(xEnd, yEnd);\n    this.currentPath_.push({\n      type: arcType,\n      x: p.x,\n      y: p.y,\n      radius: aRadius,\n      xStart: pStart.x,\n      yStart: pStart.y,\n      xEnd: pEnd.x,\n      yEnd: pEnd.y\n    });\n  };\n\n  contextPrototype.rect = function (aX, aY, aWidth, aHeight) {\n    if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {\n      return; //try to remove the rectangle behind radio buttons and checkboxes\n    }\n\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n  };\n\n  contextPrototype.strokeRect = function (aX, aY, aWidth, aHeight) {\n    if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {\n      return; //try to remove the rectangle behind radio buttons and checkboxes\n    }\n\n    var oldPath = this.currentPath_;\n    this.beginPath();\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.stroke();\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.fillRect = function (aX, aY, aWidth, aHeight) {\n    if (_needRemoveRect.call(this, aX, aY, aWidth, aHeight)) {\n      return; //try to remove the rectangle behind radio buttons and checkboxes\n    }\n\n    var oldPath = this.currentPath_;\n    this.beginPath();\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.fill();\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.createLinearGradient = function (aX0, aY0, aX1, aY1) {\n    var gradient = new CanvasGradient_('gradient');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    return gradient;\n  };\n\n  contextPrototype.createRadialGradient = function (aX0, aY0, aR0, aX1, aY1, aR1) {\n    var gradient = new CanvasGradient_('gradientradial');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.r0_ = aR0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    gradient.r1_ = aR1;\n    return gradient;\n  };\n\n  contextPrototype.drawImage = function (image, var_args) {//MQZ. no image drawing support for now\n  };\n\n  contextPrototype.getImageData = function (x, y, w, h) {\n    //MQZ. returns empty data buffer for now\n    return {\n      width: w,\n      height: h,\n      data: new Uint8Array(w * h * 4)\n    };\n  };\n\n  contextPrototype.stroke = function (aFill) {\n    if (this.currentPath_.length < 2) {\n      return;\n    }\n\n    var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);\n    var color = a.color; //        let opacity = a.alpha * this.globalAlpha;\n\n    var lineWidth = this.lineScale_ * this.lineWidth;\n    var min = {\n      x: null,\n      y: null\n    };\n    var max = {\n      x: null,\n      y: null\n    };\n\n    for (var _i2 = 0; _i2 < this.currentPath_.length; _i2++) {\n      var p = this.currentPath_[_i2];\n\n      switch (p.type) {\n        case 'moveTo':\n          break;\n\n        case 'lineTo':\n          if (!aFill) {\n            //lines\n            if (_i2 > 0) {\n              _drawPDFLine.call(this, this.currentPath_[_i2 - 1], p, lineWidth, color);\n            }\n          }\n\n          break;\n\n        case 'close':\n          if (!aFill) {\n            //lines\n            if (_i2 > 0) {\n              _drawPDFLine.call(this, this.currentPath_[_i2 - 1], this.currentPath_[0], lineWidth, color);\n            }\n          }\n\n          p = null;\n          break;\n\n        case 'bezierCurveTo':\n          break;\n\n        case 'at':\n        case 'wa':\n          break;\n      } // Figure out dimensions so we can set fills' coordinates correctly\n\n\n      if (aFill && p) {\n        if (min.x == null || p.x < min.x) {\n          min.x = p.x;\n        }\n\n        if (max.x == null || p.x > max.x) {\n          max.x = p.x;\n        }\n\n        if (min.y == null || p.y < min.y) {\n          min.y = p.y;\n        }\n\n        if (max.y == null || p.y > max.y) {\n          max.y = p.y;\n        }\n      }\n    }\n\n    if (aFill) {\n      //fill\n      _drawPDFFill.call(this, min, min, max, color);\n    }\n  };\n\n  contextPrototype.fill = function () {\n    this.stroke(true);\n  };\n\n  contextPrototype.closePath = function () {\n    this.currentPath_.push({\n      type: 'close'\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  contextPrototype.getCoords_ = function (aX, aY) {\n    var m = this.m_;\n    return {\n      x: aX * m[0][0] + aY * m[1][0] + m[2][0],\n      y: aX * m[0][1] + aY * m[1][1] + m[2][1]\n    };\n  };\n\n  contextPrototype.save = function () {\n    var o = {};\n    copyState(this, o);\n    this.aStack_.push(o);\n    this.mStack_.push(this.m_);\n    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);\n  };\n\n  contextPrototype.restore = function () {\n    copyState(this.aStack_.pop(), this);\n    this.m_ = this.mStack_.pop();\n  };\n\n  function matrixIsFinite(m) {\n    for (var _j = 0; _j < 3; _j++) {\n      for (var k = 0; k < 2; k++) {\n        if (!isFinite(m[_j][k]) || isNaN(m[_j][k])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function setM(ctx, m, updateLineScale) {\n    if (!matrixIsFinite(m)) {\n      return;\n    }\n\n    ctx.m_ = m;\n\n    if (updateLineScale) {\n      // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];\n      ctx.lineScale_ = sqrt(abs(det));\n    }\n  }\n\n  contextPrototype.translate = function (aX, aY) {\n    var m1 = [[1, 0, 0], [0, 1, 0], [aX, aY, 1]];\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.rotate = function (aRot) {\n    var c = mc(aRot);\n    var s = ms(aRot);\n    var m1 = [[c, s, 0], [-s, c, 0], [0, 0, 1]];\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.scale = function (aX, aY) {\n    this.arcScaleX_ *= aX;\n    this.arcScaleY_ *= aY;\n    var m1 = [[aX, 0, 0], [0, aY, 0], [0, 0, 1]];\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.transform = function (m11, m12, m21, m22, dx, dy) {\n    var m1 = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.setTransform = function (m11, m12, m21, m22, dx, dy) {\n    var m = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];\n    setM(this, m, true);\n  };\n  /******** STUBS ********/\n\n\n  contextPrototype.clip = function () {// TODO: Implement\n  };\n\n  contextPrototype.arcTo = function () {// TODO: Implement\n  };\n\n  contextPrototype.createPattern = function () {\n    return new CanvasPattern_();\n  }; // Gradient / Pattern Stubs\n\n\n  function CanvasGradient_(aType) {\n    this.type_ = aType;\n    this.x0_ = 0;\n    this.y0_ = 0;\n    this.r0_ = 0;\n    this.x1_ = 0;\n    this.y1_ = 0;\n    this.r1_ = 0;\n    this.colors_ = [];\n  }\n\n  CanvasGradient_.prototype.addColorStop = function (aOffset, aColor) {\n    aColor = processStyle(aColor);\n    this.colors_.push({\n      offset: aOffset,\n      color: aColor.color,\n      alpha: aColor.alpha\n    });\n  };\n\n  function CanvasPattern_() {} // set up externs\n\n\n  module.exports = CanvasRenderingContext2D_; //  CanvasRenderingContext2D = CanvasRenderingContext2D_;\n  //  CanvasGradient = CanvasGradient_;\n  //  CanvasPattern = CanvasPattern_;\n})();","map":null,"metadata":{},"sourceType":"script"}