{"ast":null,"code":"/**\n * parseTable accumulator, for pdfreader, used by the Rule class.\n * items are classified into columns and rows, based on their left and top coordinates,\n * and left position of column headers.\n * TODO: use TableParser\n * @author Adrien Joly, http://github.com/adrienjoly\n * This content is released under the MIT License.\n **/\nfunction getTopPos(item) {\n  return item.y;\n}\n\nfunction getLeftPos(item) {\n  return item.x;\n}\n\nfunction getText(item) {\n  return item.text;\n}\n\n;\n/**\n * makeClassifier(): makes a classifier, based on an array of numbers and an expected number of clusters.\n * nbClusters: expected number of clusters\n * arr: array of numbers\n * => returns a function that takes a number, and returns the number of its corresponding column.\n **/\n\nfunction makeFloorClassifier(nbClusters, arr) {\n  var min = Math.min.apply(Math, arr);\n  var delta = Math.max.apply(Math, arr) - min;\n  min -= delta / nbClusters / 2;\n  return function classify(value) {\n    return Math.floor(nbClusters * (value - min) / delta);\n  };\n}\n\nfunction makeColumnClassifier(header) {\n  var colX = [0].concat(header.map(getLeftPos)).sort(function (a, b) {\n    return a - b;\n  });\n  return function classify(item) {\n    for (var i = colX.length - 1; i > -1; --i) {\n      if (getLeftPos(item) >= colX[i]) return i;\n    }\n  };\n}\n\nfunction buildRowList(items, classifyRow) {\n  var rows = [];\n\n  for (var i in items) {\n    var item = items[i];\n    var row = classifyRow(getTopPos(item));\n    (rows[row] = rows[row] || []).push(item);\n  }\n\n  return rows;\n}\n\nfunction joinCellCollisions(separ) {\n  return function (cell) {\n    return (cell || []).map(getText).join(separ).substr(0, 7);\n  };\n}\n\nfunction fillTab(str) {\n  return str.substr(0, 7);\n}\n\nfunction renderTable(table) {\n  return (table || []).map(function (row) {\n    return (row || []).map(fillTab).join(\"\\t\");\n  }).join(\"\\n\");\n}\n\nfunction renderMatrix(matrix) {\n  return (matrix || []).map(function (row) {\n    return (row || []).map(joinCellCollisions(\"+\")).join(\"\\t\");\n  }).join(\"\\n\");\n}\n\nfunction renderRows(rows) {\n  return (rows || []).map(function (row, rowId) {\n    var cells = [rowId + \":\"];\n\n    for (var i in row) {\n      cells.push((Math.floor(row[i].x) + \":\" + row[i].text).substr(0, 7));\n    }\n\n    return cells.join(\"\\t\");\n  }).join(\"\\n\");\n}\n\nfunction renderItems(items) {\n  return items.map(function (i) {\n    return [i.y, i.x, i.text].join(\"\\t\");\n  }).join(\"\\n\");\n}\n\nfunction buildMatrix(rows, classifyColumn) {\n  var matrix = [];\n\n  for (var y in rows) {\n    var row = [];\n\n    for (var x in rows[y]) {\n      var item = rows[y][x];\n      var colN = classifyColumn(item);\n      (row[colN] = row[colN] || []).push(item);\n    }\n\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\nfunction detectCollisions(matrix) {\n  var collisions = [];\n  (matrix || []).map(function (row, rowN) {\n    (row || []).map(function (cellItems, colN) {\n      if (cellItems.length > 1) collisions.push({\n        row: rowN,\n        col: colN,\n        items: cellItems\n      });\n    });\n  });\n  return collisions;\n}\n\nfunction makeAccumulator(nbRows, headerRow) {\n  var rule = this,\n      items = [];\n  rule.nbRows = nbRows || 0;\n  rule.output = {\n    items: items,\n    rows: null,\n    matrix: null\n  };\n\n  function accumulate(item) {\n    items.push(item);\n  }\n\n  ; // when parsing is done: generate a clean table, from items.\n\n  rule.whenDone(function () {\n    // classify items into rows\n    var classifyRow = makeFloorClassifier(rule.nbRows, items.map(getTopPos)); //LOG(items.map(function(i){ return [getTopPos(i), classifyRow(getTopPos(i)), i.text].join(\"\\t\"); }).join(\"\\n\"));\n\n    this.output.rows = buildRowList(items, classifyRow); // classify row items into columns\n\n    var classifyColumn = makeColumnClassifier(this.output.rows[headerRow || 0]);\n    this.output.matrix = buildMatrix(this.output.rows, classifyColumn);\n  });\n  return accumulate; // then the same function will be run on all following items, until another rule is triggered\n}\n\n;\nmodule.exports = makeAccumulator;\nmodule.exports.renderItems = renderItems;\nmodule.exports.renderRows = renderRows;\nmodule.exports.renderMatrix = renderMatrix;\nmodule.exports.renderTable = renderTable;\nmodule.exports.detectCollisions = detectCollisions;","map":null,"metadata":{},"sourceType":"script"}