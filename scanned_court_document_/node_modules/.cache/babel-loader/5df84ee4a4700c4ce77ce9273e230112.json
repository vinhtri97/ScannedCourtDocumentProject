{"ast":null,"code":"/**\n * Rule: class that can be used to define and process data extraction rules, while parsing a PDF document.\n * @author Adrien Joly, http://github.com/adrienjoly\n * This content is released under the MIT License.\n **/\nvar LOG = require(\"./lib/LOG.js\");\n/**\n * regexp: a regular expression which a PDF item's text must match in order to execute that rule.\n * => a Rule object exposes \"accumulators\": methods that defines the data extraction strategy of a rule.\n **/\n\n\nfunction Rule(regexp) {\n  this.regexp = regexp;\n  var self = this; // proxy accumulators methods\n\n  Object.keys(Rule.accumulators).forEach(function (name) {\n    self[name] = function () {\n      LOG(\"building rule:\", regexp, \"->\", name);\n      self.methodName = name;\n      self.accumulatorParams = arguments;\n      self.accumulatorBuilder = Rule.accumulators[name];\n      return self;\n    };\n  });\n} // shortcut for defining Rule objects in a more concise manner\n\n\nRule.on = function (regexp) {\n  return new Rule(regexp);\n};\n\nRule.after = function (regexp) {\n  var rule = new Rule(regexp);\n  rule.skipCurrentItem = true;\n  return rule;\n};\n/**\n * then(): defines a function to be called after a Rule's accumulator has finished processing items.\n * fct: the function to be called after a Rule's accumulator has finished processing items.\n *      the output of the accumulator will be passed as the first parameter of that function.\n **/\n\n\nRule.prototype.then = function (fct) {\n  var self = this;\n\n  this.terminate = function () {\n    fct.call(self, self.output);\n  };\n\n  return this;\n}; // private function that checks a PDF item against the Rule's regexp, and returns the corresponding accumulator.\n\n\nRule.prototype.test = function (item) {\n  if (this.regexp.test(item.text)) {\n    // lazy init of accumulators: build and init the accumulator on first match\n    this.currentItem = item;\n\n    if (!this.accumulatorImpl && this.accumulatorBuilder) {\n      this.accumulatorImpl = this.accumulatorBuilder.apply(this, this.accumulatorParams);\n      this.accumulatorImpl.methodName = this.methodName;\n      this.accumulatorImpl.terminate = this.terminate;\n    }\n\n    return this.accumulatorImpl;\n  }\n}; // intended to be run from accumulator, in order to process output before calling termination then() handler.\n\n\nRule.prototype.whenDone = function (fct) {\n  var self = this;\n  var then = this.terminate;\n\n  this.terminate = function () {\n    fct.call(self);\n    then();\n  };\n};\n/**\n * rules: array of Rule objects that will be executed one-by-one, whenever a PDF item matches a rule.\n *        each rule can only be executed once.\n * => returns a function to be called for each item by the PdfReader.\n **/\n\n\nRule.makeItemProcessor = function (rules) {\n  var currentAccumulator = null;\n\n  function terminateAccumulator() {\n    var terminatePreviousAcc = (currentAccumulator || {}).terminate;\n\n    if (terminatePreviousAcc) {\n      LOG(\"terminating accumulator:\", currentAccumulator.methodName);\n      terminatePreviousAcc(currentAccumulator); // TODO: remove currentAccumulator parameter\n    }\n  }\n\n  var applyRulesOnNextItem = true;\n  return function (item) {\n    if (!item) // last item of the file => flush buffers\n      return terminateAccumulator();else if (!item.text) return; //LOG(\"ITEM:\", item.text, \"=> apply rules:\", applyRulesOnNextItem);\n\n    if (applyRulesOnNextItem) for (var r in rules) {\n      var accumulator = rules[r].test(item);\n\n      if (accumulator) {\n        terminateAccumulator();\n        LOG(\"current accumulator:\", accumulator.methodName);\n        if (rules[r].skipCurrentItem) applyRulesOnNextItem = false;\n        currentAccumulator = accumulator;\n        delete rules[r];\n        return;\n      }\n    } else applyRulesOnNextItem = true; // if reaching this point, the current item matches none of the rules => accumulating data on current accumulator\n\n    if (currentAccumulator) applyRulesOnNextItem = !currentAccumulator(item);\n  };\n};\n/**\n * Rule.accumulators: array of accumulators that can be used for defining Rule objects.\n * An accumulator is a function that may (or may not) accept parameters, to be provided by the developer of a parser.\n * It returns another function that will be run on every following PDF item, in order to accumulate data.\n * The output of an accumulator is stored in this.output (field of its parent Rule object).\n **/\n\n\nRule.accumulators = {\n  stopAccumulating: function stopAccumulating() {\n    return function () {};\n  }\n}; // method for adding accumulators\n\nRule.addAccumulator = function (methodName, methodBuilder) {\n  Rule.accumulators[methodName] = methodBuilder;\n};\n/**\n * This accumulator will store the values extracted by the regexp of the Rule object,\n * on the current matching PDF item, into an array.\n **/\n\n\nRule.addAccumulator(\"extractRegexpValues\", function () {\n  var matches = this.regexp.exec(this.currentItem.text);\n  this.output = matches.slice(1);\n  return function () {}; // following lines are not to be processed by this accumulator\n});\n/**\n * This accumulator will store the value of the next PDF item.\n **/\n\nRule.addAccumulator(\"parseNextItemValue\", function () {\n  var self = this,\n      done = false;\n  return function (item) {\n    if (done) return;\n    done = true;\n    self.output = item.text;\n  };\n});\n/**\n * This accumulator will store the text of all following PDF items into an array.\n **/\n\nRule.addAccumulator(\"accumulateAfterHeading\", function () {\n  var output = this.output = [];\n  return function accumulate(item) {\n    output.push(item.text);\n  };\n});\n/**\n * This accumulator will store the text of all following PDF items with equal x-coordinates.\n **/\n\nRule.addAccumulator(\"accumulateFromSameX\", function () {\n  var output = this.output = [],\n      x = null;\n  return function accumulate(item) {\n    if (x === null) x = item.x;\n    if (x == item.x) output.push(item.text);\n  };\n});\n/**\n * This accumulator will store a table by detecting its columns, given their names.\n **/\n\nRule.addAccumulator(\"parseColumns\", require(\"./lib/parseColumns.js\"));\n/**\n * This accumulator will store a table by detecting its columns, given their count.\n **/\n\nRule.addAccumulator(\"parseTable\", require(\"./lib/parseTable.js\"));\nmodule.exports = Rule;","map":null,"metadata":{},"sourceType":"script"}